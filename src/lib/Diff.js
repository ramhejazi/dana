const
	_          = require('lodash')
	, sql      = require('./sql')
	, deepDiff = require('deep-diff').diff;

/**
 * @class for comparing tables (old schemata vs new schemata)
 * It generates SQL based on differences between 2 schemata
 * @author Ram Hejazi
 * @license MIT
 *
 * @property {array} oTables Old schemata/table definitions
 * @property {array} nTables New schemata/table definitions
 * @property {array} _oIds An array of all `_fid` properties of the old schemata
 * @property {array} _nIds An array of all `_fid` properties of the new schemata
 * @property {array} _newIds An array of all new `_fid` properies. `new` here refers
 * to models that are created after creating the last migration file. In other words
 * the `_fid` doesn't exist in the last snapshot.
 * @property {array} _createdTables A list of created tables
 * @property {array} _droppedTables A list of dropped tables
 * @property {array} _logs A list of all main actions
 * @property {array} up list of all `up` sql lines for the new migration file
 * @property {array} dn list of all `down` sql lines for the new migration file
 */

class Diff {

	/**
	 * Creates a new diff instance
	 *
	 * @param {Array} oTables Old schemata/table definitions.
	 * The data is generated by reading `specs` property of the last migration table.
	 * @param {Array} nTables New schemata/tables definitions.
	 * The data is generated by reading all models in `models` directory.
	 */
	constructor(oTables, nTables) {
		this.oTables = oTables;
		this.nTables = nTables;
		this._oIds = _.map(oTables, '_fid');
		this._nIds = _.map(nTables, '_fid');
		this._newIds = _.without(this._nIds, ...this._oIds);
		this._droppedTables = [];
		this._createdTables = [];
		this._logs = [];
		this.up = [];
		this.dn = [];
		this._make();
	}


	/**
	 * Get summary of all main actions performed
	 * @returns {array}
	 */
	getLogs() {
		return this._logs;
	}


	/**
	 * Is there any differences between old and new schemata?
	 * @returns {boolean}
	 */
	hasChanged() {
		return this.up.length > 0 || this.dn.length > 0;
	}


	/**
	 * Get migration data for new migration file
	 * @returns {object} An object with `up` and `down` properties
	 */
	getMigrationData() {
		return {
			up: this.up.join('\n'),
			down: this.dn.join('\n')
		};
	}


	/**
	 * Generate SQL for new migration file by filling `up` and `dn` array properties
	 * Each array element of the `up` and `dn` properties represents a SQL line
	 */
	_make() {
		this.oTables.forEach(oTable => {
			const nTable = this.nTables.find(ns => ns._fid === oTable._fid);
			if (nTable) {
				this._diffTables(oTable, nTable);
			} else {
				this._dropTable('up', oTable);
				this._createTable('dn', oTable);
				// Make sure table's indexes are added after rolling-back
				(oTable.schema.indexes || []).forEach(index => {
					this._createIndex('dn', oTable.tableName, index);
				});
			}
		});
		this._newIds.forEach(nId => {
			const nTable = this.nTables.find(tbl => tbl._fid === nId);
			this._createTable('up', nTable);
			this._dropTable('dn', nTable);
			(nTable.schema.indexes || []).forEach(index => {
				/**
				 * @todo Check necessity of removing indexes after removing tables!
				 */
				this._createIndex('up', nTable.tableName, index);
			});
		});
	}


	/**
	 * Compare 2 table schemata.
	 * @param oTable The old table schema
	 * @param nTable Possibly new schema of the table
	 */
	_diffTables(oTable, nTable) {
		const oTableName = oTable.tableName;
		const nTableName = nTable.tableName;
		const tableNameHasChanged = oTableName !== nTableName;
		const {
			charset: nCharset,
			collation: nCollation,
			columns: nColumns
		} = nTable.schema;

		const {
			charset: oCharset,
			collation: oCollation,
			columns: oColumns
		} = oTable.schema;

		if ( tableNameHasChanged ) {
			this._renameTable('up', oTableName, nTableName);
			this._renameTable('dn', nTableName, oTableName);
		}

		if ( (nCharset !== oCharset) || (nCollation !== oCollation) ) {
			this._changeTableCharset('up', nTableName, nCharset, nCollation, oCharset, oCollation);
			this._changeTableCharset('dn', oTableName, oCharset,oCollation);
		}

		const columnsDiff = deepDiff(oColumns, nColumns) || [];
		columnsDiff.forEach(d => {
			const colName = d.path[0];
			// 'N' indicates a newly added property/element
			if (d.kind === 'N') {
				const nCol = nColumns[colName];
				this._addColumn('up', nTableName, colName, nCol);
				this._dropColumn('dn', nTableName, colName);
			}
			// 'E' indicates a property/element was edited
			// 'A' indicates a change occurred within an array
			else if (d.kind === 'E' || d.kind === 'A') {
				const nCol = nColumns[colName];
				const oCol = oColumns[colName];
				this._alterColumn('up', nTableName, colName, nCol);
				this._alterColumn('dn', oTableName, colName, oCol);
			}
			// 'D' indicates a property/element was deleted
			// Changin `if (d.kind === 'D')` into `else`
			// Point? Fixing istanbul coverage report.
			// The `d.kind` can only be `D` anyways and relevant tests are passed!
			else {
				this._dropColumn('up', nTableName, colName);
				this._addColumn('dn', oTableName, colName, oColumns[colName]);
			}
		});

		this._diffTableIndexes(oTable, nTable);
	}


	/**
	 * Compare table's old vs new indices
	 * @param oTable The old table schema
	 * @param nTable Possibly new schema of the table
	 */
	_diffTableIndexes(oTable, nTable, tableNameHasChanged) {
		let oIndexes = oTable.schema.indexes || [];
		let nIndexes = nTable.schema.indexes || [];
		oIndexes.forEach(oindex => {
			let findex = nIndexes.find(ni => _.isEqual(ni, oindex));
			if (!findex) {
				this._dropIndex('up', nTable.tableName, oindex);
				this._createIndex('dn', oTable.tableName, oindex);
			} else if (tableNameHasChanged) {
				this._renameIndex('up', oTable.tableName, nTable.tableName, oindex );
				this._renameIndex('dn', nTable.tableName, oTable.tableName, oindex );
			}
		});
		nIndexes.forEach(nindex => {
			let findex = oIndexes.find(oindex => _.isEqual(nindex, oindex));
			if (!findex) {
				this._createIndex('up', nTable.tableName, nindex);
				this._dropIndex('dn', oTable.tableName, nindex);
			}
		});
	}


	/**
	 * Generate SQL for creating a new table
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {object} table Table schema - contents of the model
	 */
	_createTable(type, table) {
		this[type] = this[type].concat(sql.createTable(table));
		if ( type === 'up' ) {
			this._log('warn', `Creates table "${table.tableName}".`);
		}
	}


	/**
	 * Generate SQL for dropping a new table
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {object} table Table schema - contents of the model
	 */
	_dropTable(type, table) {
		this[type].push(sql.dropTable(table.tableName));
		if ( type === 'up' ) {
			this._log('warn', `Drops table "${table.tableName}".`);
		}
	}


	/**
	 * Generate SQL for adding a new column
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {string} colName Name of column
	 * @param {object|string} colDefinition
	 */
	_addColumn(type, tableName, colName, colDefinition) {
		const colSQL = sql.getColumnSQL(colDefinition);
		this[type].push(sql.addColumn(tableName, colName, colSQL));
	}


	/**
	 * Generate SQL for altering a column
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {string} colName Name of column
	 * @param {object|string} colDefinition
	 */
	_alterColumn(type, tableName, colName, colDefinition) {
		const colSQL = sql.getColumnSQL(colDefinition);
		this[type].push(sql.alterColumn(tableName, colName, colName, colSQL));
	}


	/**
	 * Generate SQL for dropping a column
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {string} colName Name of column
	 */
	_dropColumn(type, tableName, colName) {
		this[type].push(sql.dropColumn(tableName, colName));
	}


	/**
	 * Generate SQL for renaming a table
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} oTableName Old table name
	 * @param {string} nTableName New table name
	 */
	_renameTable(type, oTableName, nTableName) {
		this[type].push(sql.renameTable(oTableName, nTableName));
		if ( type === 'up' ) {
			this._log('warn', `Rename table "${oTableName}" to ${nTableName}`);
		}
	}


	/**
	 * Generate SQL for creating an index
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {object} index Index definition
	 */
	_createIndex(type, tableName, index) {
		this[type].push(sql.createIndex(tableName, index));
		if ( type === 'up' ) {
			this._log('warn', `Creates "${index.type}" index on table "${tableName}".`);
		}
	}

	/**
	 * Generate SQL for renaming an index
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} oTableName Old table name
	 * @param {string} nTableName New table name
	 * @param {object} index Index definition
	 */
	_renameIndex(type, oTableName, nTableName, index) {
		this[type].push(sql.renameIndex(oTableName, nTableName, index));
	}


	/**
	 * Generate SQL for dropping an index
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {object} index Index definition
	 */
	_dropIndex(type, tableName, index) {
		this[type].push(sql.dropIndex(tableName, index));
		if ( type === 'up' ) {
			this._log('warn', `Drops "${index.type}" index on table "${tableName}".`);
		}
	}


	/**
	 * Generate SQL for changing charset, collection or both
	 * @param {string} type Type of operation: "up" or "dn"
	 * @param {string} tableName
	 * @param {string} charset
	 * @param {string} collation
	 */
	_changeTableCharset(type, tableName, charset, collation) {
		this[type].push(sql.changeTableCharset(tableName, charset, collation));
	}


	/**
	 * Store logging of main operations
	 * @param {string} type Type of log: warning, alert, danger
	 * @param {string} message
	 */
	_log(type, message) {
		this._logs.push({ type, message });
	}

}

module.exports = Diff;
